<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flor Profesional que Nace de la Nada</title>
    <style>
        body { 
            margin: 0; 
            background: #000; 
            overflow: hidden; 
            display: flex; 
            justify-content: center; 
            align-items: center; 
            height: 100vh; 
        }
        canvas { 
            display: block; 
            box-shadow: 0 0 50px rgba(255, 255, 255, 0.1); /* Sombra sutil para profesionalismo */
        }
    </style>
</head>
<body>
<canvas id="c"></canvas>

<script>
// Canvas full screen con alta resolución
const canvas = document.getElementById('c');
const ctx = canvas.getContext('2d', { alpha: true, willReadFrequently: true }); // Optimizado para rendimiento
let w, h, cx, cy;

function resize() {
    w = canvas.width = window.innerWidth * window.devicePixelRatio; // Soporte para pantallas retina
    h = canvas.height = window.innerHeight * window.devicePixelRatio;
    cx = w / 2;
    cy = h / 2;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio); // Ajuste para alta densidad
}
resize();
window.addEventListener('resize', resize);

// Parámetros avanzados para una flor más compleja y profesional
const capas = 8;                  // Más capas para profundidad
const petalosPorCapa = 16;        // Más pétalos por capa para simetría
const radioMax = Math.min(w, h) * 0.42;
let progreso = 0;                 // Progreso de animación 0 → 1.5 para overshoot
const velocidadCrecimiento = 0.005; // Más lento para ver el detalle
const numPuntosPorPetalo = 120;   // Más puntos para curvas suaves
const numHojas = 4;               // Hojas adicionales
const radioCentroMax = 60;        // Centro más grande

// Función para generar colores degradados profesionales
function getColorCapa(capa) {
    const hue = (capa / capas) * 120 + 240; // De azul a rosa-morado
    return `hsl(${hue}, 90%, ${50 + (capa / capas) * 20}%)`;
}

// Función para dibujar un pétalo con curva Bézier simulada punto por punto
function dibujarPetalo(capa, p, progresoPetalo) {
    const radioCapa = radioMax * (capa + 1) / capas * (1 + Math.sin(progreso) * 0.05); // Ligera pulsación
    const anguloBase = (p / petalosPorCapa) * Math.PI * 2 + (capa % 2) * (Math.PI / petalosPorCapa); // Offset para naturalidad
    const color = getColorCapa(capa);

    // Puntos de control para curva Bézier (simulada con puntos intermedios)
    const control1Ang = anguloBase - 0.3;
    const control2Ang = anguloBase + 0.3;
    const control1Radio = radioCapa * 0.4;
    const control2Radio = radioCapa * 0.6;

    for (let i = 0; i <= numPuntosPorPetalo; i++) {
        const t = i / numPuntosPorPetalo;
        if (t > progresoPetalo) break;

        // Interpolación cúbica para forma de pétalo realista
        const u = 1 - t;
        const tt = t * t;
        const uu = u * u;
        const uuu = uu * u;
        const ttt = tt * t;

        // Posiciones Bézier
        const px = uuu * cx + 3 * uu * t * (cx + Math.cos(control1Ang) * control1Radio) + 
                   3 * u * tt * (cx + Math.cos(control2Ang) * control2Radio) + 
                   ttt * (cx + Math.cos(anguloBase) * radioCapa);
        const py = uuu * cy + 3 * uu * t * (cy + Math.sin(control1Ang) * control1Radio) + 
                   3 * u * tt * (cy + Math.sin(control2Ang) * control2Radio) + 
                   ttt * (cy + Math.sin(anguloBase) * radioCapa * 0.7); // Elongado

        // Añadir detalle ondulado
        const onda = Math.sin(t * Math.PI * 10 + capa) * 8 * t * (1 - t);

        const x = px + Math.cos(anguloBase + Math.PI / 2) * onda;
        const y = py + Math.sin(anguloBase + Math.PI / 2) * onda;

        // Dibujo con gradiente y sombra
        const grad = ctx.createRadialGradient(cx, cy, 0, x, y, 10);
        grad.addColorStop(0, color);
        grad.addColorStop(1, 'rgba(0,0,0,0)');
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x, y, 6 + Math.sin(t * Math.PI) * 4, 0, Math.PI * 2); // Puntos variables para textura
        ctx.fill();

        // Sombra sutil
        ctx.shadowColor = 'rgba(255,255,255,0.1)';
        ctx.shadowBlur = 5;
    }
}

// Función para dibujar el centro con texturas
function dibujarCentro(progresoCentro) {
    const radioCentro = radioCentroMax * progresoCentro;
    const grad = ctx.createRadialGradient(cx, cy, 0, cx, cy, radioCentro);
    grad.addColorStop(0, '#ffff33');
    grad.addColorStop(0.4, '#ffcc00');
    grad.addColorStop(0.7, '#ff6600');
    grad.addColorStop(1, '#ff3300');
    ctx.fillStyle = grad;
    ctx.beginPath();
    ctx.arc(cx, cy, radioCentro, 0, Math.PI * 2);
    ctx.fill();

    // Textura de polen (puntos aleatorios)
    for (let i = 0; i < 150 * progresoCentro; i++) {
        const ang = Math.random() * Math.PI * 2;
        const r = Math.random() * radioCentro * 0.8;
        const x = cx + Math.cos(ang) * r;
        const y = cy + Math.sin(ang) * r;
        ctx.fillStyle = `rgba(255,255,0,${0.5 + Math.random() * 0.5})`;
        ctx.beginPath();
        ctx.arc(x, y, 1 + Math.random() * 2, 0, Math.PI * 2);
        ctx.fill();
    }
}

// Función para dibujar el tallo con curvas y grosor variable
function dibujarTallo(progresoTallo) {
    const largoTallo = (h - cy + 150) * progresoTallo;
    ctx.strokeStyle = '#006600';
    ctx.lineWidth = 18 * (1 - (progresoTallo * 0.3)); // Más grueso en la base
    ctx.lineCap = 'round';
    ctx.beginPath();
    ctx.moveTo(cx, cy);

    // Curva natural con ondas
    for (let i = 0; i < 20; i++) {
        const t = i / 20;
        const y = cy + t * largoTallo;
        const x = cx + Math.sin(t * Math.PI * 4) * 20 * t; // Ondas suaves
        ctx.lineTo(x, y);
    }
    ctx.stroke();

    // Venas en el tallo
    ctx.strokeStyle = '#004400';
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(cx, cy);
    for (let i = 0; i < 20; i++) {
        const t = i / 20;
        const y = cy + t * largoTallo;
        const x = cx + Math.sin(t * Math.PI * 4) * 20 * t + Math.sin(y * 0.1) * 3;
        ctx.lineTo(x, y);
    }
    ctx.stroke();
}

// Función para dibujar hojas con venas
function dibujarHojas(progresoHojas) {
    for (let hoja = 0; hoja < numHojas; hoja++) {
        const posicionY = cy + (h - cy) * (0.3 + hoja * 0.15);
        const lado = hoja % 2 === 0 ? 1 : -1;
        const anguloHoja = lado * (Math.PI / 4 + Math.random() * 0.2);
        const largoHoja = 120 + hoja * 20;
        const anchoHoja = 50 + hoja * 10;

        if (progresoHojas < (hoja + 1) / numHojas) continue;

        ctx.save();
        ctx.translate(cx, posicionY);
        ctx.rotate(anguloHoja);

        // Forma de hoja elíptica con punta
        ctx.fillStyle = '#008000';
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.bezierCurveTo(largoHoja / 3, -anchoHoja, 2 * largoHoja / 3, -anchoHoja, largoHoja, 0);
        ctx.bezierCurveTo(2 * largoHoja / 3, anchoHoja, largoHoja / 3, anchoHoja, 0, 0);
        ctx.fill();

        // Venas en la hoja
        ctx.strokeStyle = '#004d00';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, 0);
        ctx.lineTo(largoHoja, 0);
        for (let v = 1; v <= 5; v++) {
            const ty = v / 6 * largoHoja;
            ctx.moveTo(ty, 0);
            ctx.lineTo(ty + Math.random() * 20, (Math.random() > 0.5 ? 1 : -1) * (anchoHoja * 0.6));
        }
        ctx.stroke();

        ctx.restore();
    }
}

// Animación principal
function animar() {
    ctx.clearRect(0, 0, w, h);

    // Dibujar pétalos capa por capa
    for (let capa = 0; capa < capas; capa++) {
        const progresoCapa = Math.min(1, Math.max(0, (progreso - capa * 0.1) / 0.8));
        for (let p = 0; p < petalosPorCapa; p++) {
            dibujarPetalo(capa, p, progresoCapa);
        }
    }

    // Centro
    const progresoCentro = Math.min(1, Math.max(0, (progreso - 0.6) / 0.4));
    if (progresoCentro > 0) dibujarCentro(progresoCentro);

    // Tallo
    const progresoTallo = Math.min(1, Math.max(0, (progreso - 0.4) / 0.6));
    if (progresoTallo > 0) dibujarTallo(progresoTallo);

    // Hojas
    const progresoHojas = Math.min(1, Math.max(0, (progreso - 0.5) / 0.5));
    if (progresoHojas > 0) dibujarHojas(progresoHojas);

    progreso += velocidadCrecimiento;

    if (progreso < 1.2) {
        requestAnimationFrame(animar);
    } else {
        // Animación final: pulso suave y rotación ligera
        const tiempo = Date.now() * 0.0005;
        const pulso = 1 + Math.sin(tiempo) * 0.02;
        const rotacion = Math.sin(tiempo * 0.5) * 0.05;

        ctx.save();
        ctx.translate(cx, cy);
        ctx.scale(pulso, pulso);
        ctx.rotate(rotacion);
        ctx.translate(-cx, -cy);

        // Redibujar todo para el pulso
        for (let capa = 0; capa < capas; capa++) {
            for (let p = 0; p < petalosPorCapa; p++) {
                dibujarPetalo(capa, p, 1);
            }
        }
        dibujarCentro(1);
        dibujarTallo(1);
        dibujarHojas(1);

        ctx.restore();

        requestAnimationFrame(animar);
    }
}

animar();
</script>
</body>
</html>